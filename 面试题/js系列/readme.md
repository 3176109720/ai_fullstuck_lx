# 1. js数组上有哪些方法？
1. 增加： push  unshift  splice  concat
2. 删除：pop  shift  splice  slice
3. 改：reverse sort  
4. 查：indexOf includes  lastIndexOf  find
5. 转换：join
6. 迭代：forEach  map  filter  some  every 
7. Array.from()   Array.of()


# 2. js字符串上有哪些方法？
1. 增：concat
2. 删: slice  substr  substring
3. 改：replace  trimRight  trimLeft  trim   padStart  padEnd  toUpperCase toLowerCase
4. 查：indexOf includes lastIndexOf find  endsWith  startWith
5. 转换: split

# 3. 谈谈js中的类型转换机制
- 是什么：
js中有原始类型和引用类型：
原始类型：number  string  symbol  boolean  undefined  null  Bigint 
引用类型：[]  {}  function  Date  Regexp  Set  Map

通常开发过程中，会用到一些显示类型转换的手段来完成逻辑开发
Number() ...

在V8执行过程中还存在另一种类型转换 --- 隐式类型转换

通常发生在  比较运算符  和  算术运算符

==  !=  <  >  if  while

+ - * / %


[] == ![]  


# 4. == 和 === 的区别？

- == 是相等运算符，用于比较两个值是否相等。在进行比较时，如果两个操作数的类型不同，JavaScript 会尝试进行类型转换，然后再进行比较。这种类型转换的行为被称为隐式类型转换（Implicit Type Conversion）。例如：

10 == "10" // true，因为字符串 "10" 被转换为数字 10，然后进行比较
0 == false // true，因为布尔值 false 被转换为数字 0，然后进行比较

- === 是严格相等运算符，也被称为恒等运算符，它除了比较值是否相等外，还要求比较的两个值的数据类型也必须相等。也就是说，在使用 === 进行比较时，不会进行类型转换。例如：

10 === "10" // false，因为它们的类型分别是数字和字符串，不同类型直接返回 false
0 === false // false，因为它们的类型不同，一个是数字，一个是布尔值

# 5. 深浅拷贝的区别？ 如何实现一个深拷贝？
- 深浅拷贝通常只针对应用类型 
  原始类型是单纯的赋值

- 浅拷贝: 只拷贝一层对象，复制这一层对象中的原始值，如果有引用类型的话，就复制它的指针

常见浅拷贝方法
  Object.assign()  concat  slice  解构

- 深拷贝: 递归拷贝，所有类型的属性值都会被复制，原对象的修改不会影响靠背后的对象
  JSON.parse(JSON.stringify(obj)) 无法处理 undefined、function、Symbol 等特殊类型，这些类型在转换过程中会丢失
  
# 6. 说说你对闭包的理解
- 闭包是什么 
当一个函数中的内部函数被拿到函数外部调用，又因为在js中内层作用域总是能访问外层作用域的，那么内部函数存在对外部函数中变量的引用的话，这些变量的集合称之为闭包

- 使用场景:
 1. 创建私有变量  (全局变量不好维护)
 2. 延长变量的生命周期
 3. 实现柯里化 (颗粒化)

- 闭包的缺点
会造成内存泄露

# 7. 什么是柯里化
- 是什么
是指将一个接受多个参数的函数转化为多个只接受一个参数的函数

# 8. 说说你对作用域的理解
- 什么是作用域
变量和函数能够生效的区域称为作用域，作用域决定了变量和函数的可见性

- 作用域的划分
 1. 全局作用域 
 2. 函数作用域 
 3. 块级作用域 

- 作用域链: 作用域只能从内到外的访问，这种访问规则形成的链状关系我们称之为作用域链

- 词法作用域: 指的是函数或变量定义的区域

# 9. 说说你对原型的理解
- 什么是原型
 1. 显示原型 指的是函数身上自带的 prototype 属性，通常可以将一些属性和方法添加到显示原型上，这样所有的实例对象都可以继承到这些属性和方法

 2. 隐式原型 __proto__ 是对象这种结构上的一个属性， 其中包含了创建了该对象时，隐式继承到的属性

 - 原型链: 创建一个实例对象时，实例对象的隐式原型===创建该对象的构造函数的显示原型，在js中对象的查找规则是先在实例对象上找，找不到的话就去实例对象的隐式原型上找，找不到的话就去实例对象的隐式原型的隐式原型上找，以此类推，直到找到为止

# 10. 说说JS中的继承
- 什么是继承
在js中，继承指的是让一个子类可以访问父类的属性和方法

- 继承有哪些方式

  1. 原型链继承：（1.无法给父类灵活传参  2.多个实例对象共用了同一个原型对象存在属性相互影响）
  2. 构造函数继承：(1.只能继承到父类身上的属性，无法继承到父类原型上的属性)
  3. 组合继承（经典继承）：(1.存在多次父类函数的调用，多造成了性能开销)
  
  4. 原型式继承：（1.因为是浅拷贝，父类中的引用类型在子类之间共用了，会相互影响, 2.子类无法添加默认属性）
  5. 寄生式继承：（1. 同上）
  6. 寄生组合式继承

  7. class 继承

# 11. 说说js中的this
  - 什么是this: this是函数在运行过程中自动生成的一个对象，用来代指作用域的指向

  - this的绑定规则 
    1. 默认绑定:当函数被独立调用时，函数的this指向window，(函数的词法作用域在哪里，this就指向那个词法作用域) 
    2. 隐式绑定: 当函数被一个对象所调用时，函数的thiamin指向该对象
    3. 隐式丢失: 当函数调用前有多个对象，函数的this指向最近的对象 
    4. 显式绑定: 使用call、apply、bind方法
    5. new绑定: 当函数被new调用时，函数的this指向新创建的对象

    箭头函数:箭头函数中的this是它外层非箭头函数的。指向也按照上面的绑定规则

# 12. new的实现原理
  1. 创建一个新的空对象。
  2. 将这个空对象的原型指向构造函数的原型对象（也就是 constructor.prototype）。
  3. 使用 call 方法调用构造函数，并将新创建的对象绑定到 this 上，以便在构造函数中可以使用 this 来引用新对象。
  4. 如果构造函数没有显式返回一个对象，则返回这个新对象。
    
  - 构造函数有返回值，且为引用类型时会覆盖new当中的返回值

# 13. call、apply、bind的实现原理
     




# 14. 说说js中的事件模型

  1. DOM0级  onclick (无法控制事件在捕获，冒泡那个阶段执行)
  2. DOM1级  addeventListen  (可以控制事件在捕获，冒泡那个阶段执行)
  3. IE模型  attachEvent  (无法控制事件在捕获，冒泡那个阶段执行)

# 15. 说说typeof和instanceof的区别
  - typeof
    能判断除了null以外的所有原始类型

  - instanceof 
    能判断一个变量是属于那种类型，
    instanceof为什么不能判断原始类型
    因为原始类型没有原型链，所以无法判断一个对象是否为另一个对象的实例

  - Object.prototype.toString(X)

    1. [].toString()  数组版本的toString
    2. Object.prototype.toString.call()  对象版本的toString
    3. {}.toString()  对象版本的toString

    该方法会让 变量 X 调用对象上的 toString 函数，而toString返回值为 '[object 类型]' 

  - Array.isArray()
    只能判断一个变量是否是数组

# 16. 说说Ajax的原理
  - Ajax是什么
    Async JavaScript and XML , 是一种异步js和网页交互的技术，可以实行不刷新网页就跟服务器交换数据，更新界面

  - 实现过程
    1. 创建一个XHR实例对象
    2. 调用实例对象中的open方法与服务器建立连接 
    3. 调用实例对象中的send方法发送请求
    4. 监听onreadystatechange事件，通过判断readyState的值来获取最终数据
    5. 将数据更新到html面

# 17. 怎么实现上拉加载下拉刷新
  1. 监听 touchstar  touchmove  touchend  事件，记录手指移动的距离，大于临界值时实现刷新操作，其中使用 transform: translateY 来添加各处的动画

  2. 根据手指滑动的方向和容器顶端或底部到屏幕的距离来确定


# 18. 防抖节流

# 19. 
  